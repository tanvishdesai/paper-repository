[
  {
    "year": 2009,
    "paper_code": "CS",
    "question_no": "Q.17",
    "question_text": "Match all items in Group 1 with correct options from those given in Group 2.\nGroup 1\nP. Regular expression\nQ. Pushdown automata\nR. Dataflow analysis\nS. Register allocation\nGroup 2\n1. Syntax analysis\n2. Code generation\n3. Lexical analysis\n4. Code Optimization\n(A) P – 4, Q – 1, R – 2, S – 3\n(B) P – 3, Q – 1, R – 4, S – 2\n(C) P – 3, Q – 4, R – 1, S – 2\n(D) P – 2, Q – 1, R – 4, S – 3",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "OTHER: Mapping compiler phases to concepts",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2009 CS",
    "confidence": 0.4
  },
  {
    "year": 2009,
    "paper_code": "CS",
    "question_no": "Q.42",
    "question_text": "Which of the following statements are TRUE ?\nI. There exist parsing algorithms for some programming languages whose complexities are less than Θ(n³).\nII. A programming language which allows recursion can be implemented with static storage allocation.\nIII. No L-attributed definition can be evaluated in the framework of bottom-up parsing.\nIV. Code improving transformations can be performed at both source language and intermediate code level.\n(A) I and II\n(B) I and IV\n(C) III and IV\n(D) I, III and IV",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Parsing, syntax-directed translation.",
    "theoretical_practical": "theoretical",
    "marks": 2,
    "provenance": "GATE 2009 CS",
    "confidence": 0.9
  },
  {
    "year": 2010,
    "paper_code": "CS",
    "question_no": "13",
    "question_text": "Which data structure in a compiler is used for managing information about variables and their attributes?\n(A) Abstract syntax tree\n(B) Symbol table\n(C) Semantic stack\n(D) Parse table",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATEFORUM 2010 CS",
    "confidence": 0.9
  },
  {
    "year": 2010,
    "paper_code": "CS",
    "question_no": "14",
    "question_text": "Which languages necessarily need heap allocation in the runtime environment?\n(A) Those that support recursion\n(B) Those that use dynamic scoping\n(C) Those that allow dynamic data structures\n(D) Those that use global variables",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Runtime environments",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATEFORUM 2010 CS",
    "confidence": 1
  },
  {
    "year": 2010,
    "paper_code": "CS",
    "question_no": "37",
    "question_text": "The program below uses six temporary variables a, b, c, d, e, f.\na = 1\nb = 10\nc = 20\nd = a + b\ne = c + d\nf = c + e\nb = c + e\ne = b + f\nd = 5 + e\nreturn d + f\nAssuming that all operations take their operands from registers, what is the minimum number of registers needed to execute this program without spilling?\n(A) 2\n(B) 3\n(C) 4\n(D) 6",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Local optimization, Data flow analyses: constant propagation, liveness analysis, common sub expression elimination",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATEFORUM 2010 CS",
    "confidence": 1
  },
  {
    "year": 2010,
    "paper_code": "CS",
    "question_no": "38",
    "question_text": "The grammar S → aSa|bS|c is\n(A) LL(1) but not LR(1)\n(B) LR(1) but not LL(1)\n(C) Both LL(1) and LR(1)\n(D) Neither LL(1) nor LR(1)",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation",
    "theoretical_practical": "theoretical",
    "marks": 2,
    "provenance": "GATEFORUM 2010 CS",
    "confidence": 1
  },
  {
    "year": 2011,
    "paper_code": "CS",
    "question_no": "Q.1",
    "question_text": "In a compiler, keywords of a language are recognized during\n(A) parsing of the program\n(B) the code generation\n(C) the lexical analysis of the program\n(D) dataflow analysis",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE2011_CS",
    "confidence": 1
  },
  {
    "year": 2011,
    "paper_code": "CS",
    "question_no": "Q.19",
    "question_text": "The lexical analysis for a modern computer language such as Java needs the power of which one of the following machine models in a necessary and sufficient sense?\n(A) Finite state automata\n(B) Deterministic pushdown automata\n(C) Non-deterministic pushdown automata\n(D) Turing machine",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE2011_CS",
    "confidence": 1
  },
  {
    "year": 2011,
    "paper_code": "CS",
    "question_no": "Q.27",
    "question_text": "Consider two binary operators '↑' and '↓' with the precedence of operator ↓ being lower than that of the operator ↑. Operator ↑ is right associative while operator ↓ is left associative. Which one of the following represents the parse tree for expression (7↓3↑4↑3↓2)?",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "parsing",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE2011_CS",
    "confidence": 1
  },
  {
    "year": 2011,
    "paper_code": "CS",
    "question_no": "Q.36",
    "question_text": "Consider evaluating the following expression tree on a machine with load-store architecture in which memory can be accessed only through load and store instructions. The variables a, b, c, d and e are initially stored in memory. The binary operators used in this expression tree can be evaluated by the machine only when the operands are in registers. The instructions produce result only in a register. If no intermediate results can be stored in memory, what is the minimum number of registers needed to evaluate this expression?\n(A) 2\n(B) 9\n(C) 5\n(D) 3",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Intermediate code generation",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE2011_CS",
    "confidence": 0.9
  },
  {
    "year": 2012,
    "paper_code": "CS",
    "question_no": "Q.36",
    "question_text": "Consider the program given below, in a block-structured pseudo-language with lexical scoping and nesting of procedures permitted. ... Consider the calling chain: Main -> A1 -> A2 -> A21 -> A1. The correct set of activation records along with their access links is given by",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Runtime environments.",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE 2012 Question Paper",
    "confidence": 1
  },
  {
    "year": 2012,
    "paper_code": "CS",
    "question_no": "Q.52",
    "question_text": "For the grammar below, a partial LL(1) parsing table is also presented along with the grammar. ... The FIRST and FOLLOW sets for the non-terminals A and B are",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation.",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE 2012 Question Paper",
    "confidence": 1
  },
  {
    "year": 2012,
    "paper_code": "CS",
    "question_no": "Q.53",
    "question_text": "For the grammar below, a partial LL(1) parsing table is also presented along with the grammar. ... The appropriate entries for E1, E2, and E3 are",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation.",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE 2012 Question Paper",
    "confidence": 1
  },
  {
    "year": 2013,
    "paper_code": "CS",
    "question_no": "Q.9",
    "question_text": "What is the maximum number of reduce moves that can be taken by a bottom-up parser for a grammar with no epsilon- and unit-production (i.e., of type A → ε and A → a) to parse a string with n tokens?\n(A) n/2\n(B) n-1\n(C) 2n-1\n(D) 2^n",
    "subject": "Compiler Design",
    "chapter": "Lexical analysis, parsing, syntax-directed translation.",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation.",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2013 Paper",
    "confidence": 1
  },
  {
    "year": 2014,
    "paper_code": "CS",
    "question_no": "17",
    "question_text": "Which one of the following is FALSE?\n(A) A basic block is a sequence of instructions where control enters the sequence at the beginning and exits at the end.\n(B) Available expression analysis can be used for common subexpression elimination.\n(C) Live variable analysis can be used for dead code elimination.\n(D) x = 4 * 5 ⇒ x = 20 is an example of common subexpression elimination.",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Local optimization, Data flow analyses: constant propagation, liveness analysis, common sub expression elimination",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE2014_CS_OCR",
    "confidence": 0.9
  },
  {
    "year": 2014,
    "paper_code": "CS",
    "question_no": "34",
    "question_text": "A canonical set of items is given below\nS → L . > R\nQ → R .\nOn input symbol < the set has\n(A) a shift-reduce conflict and a reduce-reduce conflict.\n(B) a shift-reduce conflict but not a reduce-reduce conflict.\n(C) a reduce-reduce conflict but not a shift-reduce conflict.\n(D) neither a shift-reduce nor a reduce-reduce conflict.",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation",
    "theoretical_practical": "theoretical",
    "marks": 2,
    "provenance": "GATE2014_CS_OCR",
    "confidence": 1
  },
  {
    "year": 2014,
    "paper_code": "CS-2",
    "question_no": "17",
    "question_text": "Consider the grammar defined by the following production rules, with two operators * and +\nS -> T * P\nT -> U | T * U\nP -> Q + P | Q\nQ -> id\nU -> id\nWhich one of the following is TRUE?",
    "subject": "Compiler Design",
    "chapter": "Lexical analysis, parsing, syntax-directed translation",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2014 CS SET-2",
    "confidence": 1
  },
  {
    "year": 2014,
    "paper_code": "CS-2",
    "question_no": "18",
    "question_text": "Which one of the following is NOT performed during compilation?",
    "subject": "Compiler Design",
    "chapter": "Runtime environments",
    "subtopic": "Runtime environments",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2014 CS SET-2",
    "confidence": 1
  },
  {
    "year": 2014,
    "paper_code": "CS-2",
    "question_no": "34",
    "question_text": "For a C program accessing X[i][j][k], the following intermediate code is generated by a compiler. Assume that the size of an integer is 32 bits and the size of a character is 8 bits.\nt0 = i * 1024\nt1 = j * 32\nt2 = k * 4\nt3 = t1 + t2\nt4 = t0 + t3\nt5 = X[t4]\nWhich one of the following statements about the source code for the C program is CORRECT?",
    "subject": "Compiler Design",
    "chapter": "Intermediate code generation",
    "subtopic": "Intermediate code generation",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE 2014 CS SET-2",
    "confidence": 1
  },
  {
    "year": 2015,
    "paper_code": "CS",
    "question_no": "14",
    "question_text": "In the context of abstract-syntax-tree (AST) and control-flow-graph (CFG), which one of the following is TRUE?\n(A) In both AST and CFG, let node N₂ be the successor of node N₁. In the input program, the code corresponding to N₂ is present after the code corresponding to N₁\n(B) For any input program, neither AST nor CFG will contain a cycle\n(C) The maximum number of successors of a node in an AST and a CFG depends on the input program\n(D) Each node in AST and CFG corresponds to at most one statement in the input program",
    "subject": "Compiler Design",
    "chapter": "Intermediate code generation",
    "subtopic": "Intermediate code generation",
    "theoretical_practical": "theoretical",
    "marks": null,
    "provenance": "GATE 2015 Examination - CS (Set 2, 7th February, Afternoon Session)",
    "confidence": 0.9
  },
  {
    "year": 2015,
    "paper_code": "CS",
    "question_no": "16",
    "question_text": "Among simple LR (SLR), canonical LR, and look-ahead LR (LALR), which of the following pairs identify the method that is very easy to implement and the method that is the most powerful, in that order?\n(A) SLR, LALR\n(B) Canonical LR, LALR\n(C) SLR, canonical LR\n(D) LALR, canonical LR",
    "subject": "Compiler Design",
    "chapter": "Lexical analysis, parsing, syntax-directed translation.",
    "subtopic": "parsing",
    "theoretical_practical": "theoretical",
    "marks": null,
    "provenance": "GATE 2015 CS Set 3",
    "confidence": 1
  },
  {
    "year": 2015,
    "paper_code": "CS",
    "question_no": "19",
    "question_text": "Match the following:\nP. Lexical analysis\t1. Graph coloring\nQ. Parsing\t2. DFA minimization\nR. Register allocation\t3. Post-order traversal\nS. Expression evaluation\t4. Production tree\n(A) P-2, Q-3, R-1, S-4\n(B) P-2, Q-1, R-4, S-3\n(C) P-2, Q-4, R-1, S-3\n(D) P-2, Q-3, R-4, S-1",
    "subject": "Compiler Design",
    "chapter": "Lexical analysis, parsing, syntax-directed translation",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation",
    "theoretical_practical": "theoretical",
    "marks": null,
    "provenance": "GATE 2015 Examination - CS (Set 2, 7th February, Afternoon Session)",
    "confidence": 0.8
  },
  {
    "year": 2015,
    "paper_code": "CS",
    "question_no": "29",
    "question_text": "Consider the intermediate code given below.\n(1) i = 1\n(2) j = 1\n(3) t1 = 5 * i\n(4) t2 = t1 + j\n(5) t3 = 4 * t2\n(6) t4 = t3\n(7) a[t4] = -1\n(8) j = j + 1\n(9) if j<=5 goto (3)\n(10) i=i+1\n(11) if i<5 goto (2)\nThe number of nodes and edges in the control-flow-graph constructed for the above code, respectively, are\n(A) 5 and 7\n(B) 6 and 7\n(C) 5 and 5\n(D) 7 and 8",
    "subject": "Compiler Design",
    "chapter": "Intermediate code generation",
    "subtopic": "Intermediate code generation",
    "theoretical_practical": "practical",
    "marks": null,
    "provenance": "GATE 2015 Examination - CS (Set 2, 7th February, Afternoon Session)",
    "confidence": 1
  },
  {
    "year": 2015,
    "paper_code": "CS",
    "question_no": "31",
    "question_text": "Consider the following grammar G\nS → F | H\nF → p | c\nH → d | c\nwhere S, F, and H are non-terminal symbols, p, d, and c are terminal symbols. Which of the following statement(s) is/are correct?\nS1. LL(1) can parse all strings that are generated using grammar G\nS2. LR(1) can parse all strings that are generated using grammar G\n(A) Only S1\n(B) Only S2\n(C) Both S1 and S2\n(D) Neither S1 nor S2",
    "subject": "Compiler Design",
    "chapter": "Lexical analysis, parsing, syntax-directed translation.",
    "subtopic": "parsing",
    "theoretical_practical": "theoretical",
    "marks": null,
    "provenance": "GATE 2015 CS Set 3",
    "confidence": 1
  },
  {
    "year": 2015,
    "paper_code": "CS",
    "question_no": "Q. 13",
    "question_text": "Which one of the following is TRUE at any valid state in shift-reduce parsing?\n(A) Viable prefixes appear only at the bottom of the stack and not inside\n(B) Viable prefixes appear only at the top of the stack and not inside\n(C) The stack contains only a set of viable prefixes\n(D) The stack never contains viable prefixes",
    "subject": "Compiler Design",
    "chapter": "Lexical analysis, parsing, syntax-directed translation",
    "subtopic": "parsing",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE_2015_CS_Set1_Feb7_FN",
    "confidence": 1
  },
  {
    "year": 2015,
    "paper_code": "CS",
    "question_no": "Q. 50",
    "question_text": "A variable x is said to be live at a statement Sᵢ in a program if the following three conditions hold simultaneously:\ni. There exists a statement Sⱼ that uses x\nii. There is a path from Sᵢ to Sⱼ in the flow graph corresponding to the program\niii. The path has no intervening assignment to x including at Sᵢ and Sⱼ\n[Control Flow Graph Image]\nThe variables which are live both at the statement in basic block 2 and at the statement in basic block 3 of the above control flow graph are\n(A) p, s, u\n(B) r, s, u\n(C) r, u\n(D) q, v",
    "subject": "Compiler Design",
    "chapter": "Local optimization, Data flow analyses: constant propagation, liveness analysis, common sub expression elimination",
    "subtopic": "liveness analysis",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE_2015_CS_Set1_Feb7_FN",
    "confidence": 1
  },
  {
    "year": 2015,
    "paper_code": "CS",
    "question_no": "Q. 55",
    "question_text": "The least number of temporary variables required to create a three-address code in static single assignment form for the expression q+r/3+s-t*5+u*v/w is ________",
    "subject": "Compiler Design",
    "chapter": "Intermediate code generation",
    "subtopic": "Intermediate code generation",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE_2015_CS_Set1_Feb7_FN",
    "confidence": 1
  },
  {
    "year": 2016,
    "paper_code": "CS",
    "question_no": "Q.19",
    "question_text": "Match the following:\n(P) Lexical analysis\n(Q) Top down parsing\n(R) Semantic analysis\n(S) Runtime environments\n(i) Leftmost derivation\n(ii) Type checking\n(iii) Regular expressions\n(iv) Activation records\n(A) P ↔ i, Q ↔ ii, R ↔ iv, S ↔ iii\n(B) P ↔ iii, Q ↔ i, R ↔ ii, S ↔ iv\n(C) P ↔ ii, Q ↔ iii, R ↔ i, S ↔ iv\n(D) P ↔ iv, Q ↔ i, R ↔ ii, S ↔ iii",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2016 CS Set-B",
    "confidence": 1
  },
  {
    "year": 2016,
    "paper_code": "CS",
    "question_no": "Q.19",
    "question_text": "Consider the following code segment.\nx = u - t;\ny = x * v;\nx = y + w;\ny = t - z;\ny = x * y;\nThe minimum number of total variables required to convert the above code segment to static single assignment form is __________.",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Intermediate code generation",
    "theoretical_practical": "practical",
    "marks": 1,
    "provenance": "GATE 2016 CS Set A",
    "confidence": 1
  },
  {
    "year": 2016,
    "paper_code": "CS",
    "question_no": "Q.45",
    "question_text": "Which one of the following grammars is free from left recursion?\n(A) S → AB\nA → Aa | b\nB → c\n(B) S → Ab | Bb | c\nA → Bd\nB → e\n(C) S → Aa | B\nA → Bb | Sc | ε\nB → d\n(D) S → Aa | Bb | c\nA → Bd | ε\nB → Ae | ε",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "parsing",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE 2016 CS Set-B",
    "confidence": 1
  },
  {
    "year": 2017,
    "paper_code": "CS",
    "question_no": "12",
    "question_text": "Consider the following intermediate program in three address code\np = a - b\nq = p * c\np = u * v\nq = p + q\nWhich one of the following corresponds to a static single assignment form of the above code?\n(A) p₁ = a - b\n    q₁ = p₁ * c\n    p₁ = u * v\n    q₁ = p₁ + q₁\n(B) p₃ = a - b\n    q₄ = p₃ * c\n    p₄ = u * v\n    q₅ = p₄ + q₄\n(C) p₁ = a - b\n    q₁ = p₂ * c\n    p₃ = u * v\n    q₂ = p₄ + q₃\n(D) p₁ = a - b\n    q₁ = p₁ * c\n    p₂ = u * v\n    q₂ = p₂ + q₁",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Intermediate code generation",
    "theoretical_practical": "practical",
    "marks": 1,
    "provenance": "GATE 2017 CS",
    "confidence": 0.9
  },
  {
    "year": 2017,
    "paper_code": "CS",
    "question_no": "17",
    "question_text": "Consider the following grammar:\nP → xQRS\nQ → yz | z\nR → w | ε\nS → y\nWhat is FOLLOW(Q)?\n(A) {R}\n(B) {w}\n(C) {w, y}\n(D) {w, $}",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "parsing",
    "theoretical_practical": "practical",
    "marks": 1,
    "provenance": "GATE 2017 CS",
    "confidence": 1
  },
  {
    "year": 2017,
    "paper_code": "CS",
    "question_no": "43",
    "question_text": "Consider the following grammar:\nstmt -> if expr then expr else expr; stmt | δ\nexpr -> term relop term | term\nterm -> id | number\nid -> a | b | c\nnumber -> [0-9]\nwhere relop is a relational operator (e.g., <, >, ...), δ refers to the empty statement, and if, then, else are terminals.\nConsider a program P following the above grammar containing ten if terminals. The number of control flow paths in P is ______. For example, the program\nif e₁ then e₂ else e₃\nhas 2 control flow paths, e₁ → e₂ and e₁ → e₃.",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Data flow analyses: constant propagation, liveness analysis, common sub expression elimination",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE 2017 CS",
    "confidence": 0.6
  },
  {
    "year": 2017,
    "paper_code": "CS",
    "question_no": "5",
    "question_text": "Match the following according to input (from the left column) to the compiler phase (in the right column) that processes it:\n(P) Syntax tree\n(Q) Character stream\n(R) Intermediate representation\n(S) Token stream\nwith\n(i) Code generator\n(ii) Syntax analyzer\n(iii) Semantic analyzer\n(iv) Lexical analyzer",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2017 Session 2",
    "confidence": 0.8
  },
  {
    "year": 2017,
    "paper_code": "CS",
    "question_no": "52",
    "question_text": "Consider the expression (a-1) * (((b+c)/3)+d)). Let X be the minimum number of registers required by an optimal code generation (without any register spill) algorithm for a load/store architecture, in which (i) only load and store instructions can have memory operands and (ii) arithmetic instructions can have only register or immediate operands. The value of X is ______.",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Intermediate code generation",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE 2017 CS",
    "confidence": 0.8
  },
  {
    "year": 2017,
    "paper_code": "CS",
    "question_no": "6",
    "question_text": "Which of the following statements about parser is/are CORRECT?\nI. Canonical LR is more powerful than SLR.\nII. SLR is more powerful than LALR.\nIII. SLR is more powerful than Canonical LR.",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "parsing",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2017 Session 2",
    "confidence": 1
  },
  {
    "year": 2018,
    "paper_code": "CS",
    "question_no": "37",
    "question_text": "A lexical analyzer uses the following patterns to recognize three tokens T₁, T₂, and T₃ over the alphabet {a,b,c}.\nT₁: a? (b|c)*a\nT₂: b? (a|c)*b\nT₃: c? (b|a)*c\nNote that 'x?' means 0 or 1 occurrence of the symbol x. Note also that the analyzer outputs the token that matches the longest possible prefix.\nIf the string bbaacabc is processed by the analyzer, which one of the following is the sequence of tokens it outputs?",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE 2018",
    "confidence": 1
  },
  {
    "year": 2018,
    "paper_code": "CS",
    "question_no": "38",
    "question_text": "Consider the following parse tree for the expression a#b$c$d#e#f, involving two binary operators $ and #.\nWhich one of the following is correct for the given parse tree?",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "parsing",
    "theoretical_practical": "theoretical",
    "marks": 2,
    "provenance": "GATE 2018",
    "confidence": 1
  },
  {
    "year": 2018,
    "paper_code": "CS",
    "question_no": "8",
    "question_text": "Which one of the following statements is FALSE?\n(A) Context-free grammar can be used to specify both lexical and syntax rules.\n(B) Type checking is done before parsing.\n(C) High-level language programs can be translated to different Intermediate Representations.\n(D) Arguments to a function can be passed using the program stack.",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "parsing (approximate)",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2018",
    "confidence": 0.9
  },
  {
    "year": 2020,
    "paper_code": "CS",
    "question_no": "24",
    "question_text": "Consider the following grammar.\nS → aSB | d\nB → b\nThe number of reduction steps taken by a bottom-up parser while accepting the string aaadbbb is _____",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation",
    "theoretical_practical": "practical",
    "marks": 1,
    "provenance": "GATE 2020 CS",
    "confidence": 1
  },
  {
    "year": 2020,
    "paper_code": "CS",
    "question_no": "33",
    "question_text": "Consider the productions A → PQ and A → XY. Each of the five non-terminals A, P, Q, X, and Y has two attributes: s is a synthesized attribute, and i is an inherited attribute. Consider the following rules.\nRule 1: P.i = A.i + 2, Q.i = P.i + A.i, and A.s = P.s + Q.s\nRule 2: X.i = A.i + Y.s and Y.i = X.s + A.i\nWhich one of the following is TRUE?",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation",
    "theoretical_practical": "theoretical",
    "marks": 2,
    "provenance": "GATE 2020 CS",
    "confidence": 1
  },
  {
    "year": 2020,
    "paper_code": "CS",
    "question_no": "9",
    "question_text": "Consider the following statements.\nI. Symbol table is accessed only during lexical analysis and syntax analysis.\nII. Compilers for programming languages that support recursion necessarily need heap storage for memory allocation in the run-time environment.\nIII. Errors violating the condition 'any variable must be declared before its use' are detected during syntax analysis.\nWhich of the above statements is/are TRUE?",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2020 CS",
    "confidence": 0.9
  },
  {
    "year": 2021,
    "paper_code": "CS",
    "question_no": "CS Q.13",
    "question_text": "In the context of compilers, which of the following is/are NOT an intermediate representation of the source program?\n\n(A) Three address code\n(B) Abstract Syntax Tree (AST)\n(C) Control Flow Graph (CFG)\n(D) Symbol table",
    "subject": "Section 7: Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Intermediate code generation",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2021 CS Set-2",
    "confidence": 1.0
  },
  {
    "year": 2021,
    "paper_code": "CS",
    "question_no": "CS Q.3",
    "question_text": "Consider the following ANSI C program:\n\nint main() {\n  Integer x;\n  return 0;\n}\n\nWhich one of the following phases in a seven-phase C compiler will throw an error?\n\n(A) Lexical analyzer\n(B) Syntax analyzer\n(C) Semantic analyzer\n(D) Machine dependent optimizer",
    "subject": "Section 7: Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "parsing",
    "theoretical_practical": "practical",
    "marks": 1,
    "provenance": "GATE 2021 CS Set-2",
    "confidence": 1.0
  },
  {
    "year": 2021,
    "paper_code": "CS",
    "question_no": "CS Q.30",
    "question_text": "Consider the following ANSI C code segment:\n\nz = x + 3 + y->f1 + y->f2;\nfor (i = 0; i < 200; i = i + 2){\n  if (z > i) {\n    p = p + x + 3;\n    q = q + y->f1;\n  } else {\n    p = p + y->f2;\n    q = q + x + 3;\n  }\n}\n\nAssume that the variable y points to a struct (allocated on the heap) containing two fields f1 and f2, and the local variables x, y, z, p, q, and i are allotted registers. Common sub-expression elimination (CSE) optimization is applied on the code. The number of addition and dereference operations (of the form y->f1 or y->f2) in the optimized code, respectively, are:\n\n(A) 403 and 102\n(B) 203 and 2\n(C) 303 and 102\n(D) 303 and 2",
    "subject": "Section 7: Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Data flow analyses: constant propagation, liveness analysis, common sub expression elimination",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE 2021 CS Set-2",
    "confidence": 1.0
  },
  {
    "year": 2021,
    "paper_code": "CS",
    "question_no": "CS Q.38",
    "question_text": "For a statement S in a program, in the context of liveness analysis, the following sets are defined:\n\nUSE(S) : the set of variables used in S\nIN(S) : the set of variables that are live at the entry of S\nOUT(S) : the set of variables that are live at the exit of S\n\nConsider a basic block that consists of two statements, S1 followed by S2. Which one of the following statements is correct?\n\n(A) OUT(S1) = IN(S2)\n(B) OUT(S1) = IN(S1) ∪ USE(S1)\n(C) OUT(S1) = IN(S2) ∪ OUT(S2)\n(D) OUT(S1) = USE(S1) ∪ IN(S2)",
    "subject": "Section 7: Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Data flow analyses: constant propagation, liveness analysis, common sub expression elimination",
    "theoretical_practical": "theoretical",
    "marks": 2,
    "provenance": "GATE 2021 CS Set-2",
    "confidence": 1.0
  },
  {
    "year": 2021,
    "paper_code": "CS",
    "question_no": "CS Q.51",
    "question_text": "Consider the following augmented grammar with {#, @, <, >, a, b, c} as the set of terminals.\n\nS' → S\nS → S # c S\nS → S S\nS → S @\nS → < S >\nS → a\nS → b\nS → c\n\nLet I₀ = CLOSURE({S' → •S}). The number of items in the set GOTO(GOTO(I₀, <), <) is ____________.",
    "subject": "Section 7: Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "parsing",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE 2021 CS Set-2",
    "confidence": 1.0
  },
  {
    "year": 2021,
    "paper_code": "CS",
    "question_no": "CS-Q.5",
    "question_text": "Consider the following statements.\n\nS₁: Every SLR(1) grammar is unambiguous but there are certain unambiguous grammars that are not SLR(1).\nS₂: For any context-free grammar, there is a parser that takes at most O(n³) time to parse a string of length n.\n\nWhich one of the following options is correct?\n\n(A) S₁ is true and S₂ is false\n(B) S₁ is false and S₂ is true\n(C) S₁ is true and S₂ is true\n(D) S₁ is false and S₂ is false",
    "subject": "Compiler Design",
    "chapter": "parsing, syntax-directed translation",
    "subtopic": "parsing",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2021 CS Set-1",
    "confidence": 1
  },
  {
    "year": 2022,
    "paper_code": "CS",
    "question_no": "Q.13",
    "question_text": "Which one of the following statements is TRUE?\n\n(A) The LALR(1) parser for a grammar G cannot have reduce-reduce conflict if the LR(1) parser for G does not have reduce-reduce conflict.\n(B) Symbol table is accessed only during the lexical analysis phase.\n(C) Data flow analysis is necessary for run-time memory management.\n(D) LR(1) parsing is sufficient for deterministic context-free languages.",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "parsing",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2022 CS",
    "confidence": 1
  },
  {
    "year": 2022,
    "paper_code": "CS",
    "question_no": "Q.29",
    "question_text": "Consider the augmented grammar with {+, *, (, ), id} as the set of terminals.\nS' -> S\nS -> S + R | R\nR -> R * P | P\nP -> (S) | id\nIf I₀ is the set of two LR(0) items {[S' -> .S], [S -> .S + R]}, then goto(closure(I₀), +) contains exactly ___ items.",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "parsing",
    "theoretical_practical": "practical",
    "marks": 1,
    "provenance": "GATE 2022 CS",
    "confidence": 1
  },
  {
    "year": 2022,
    "paper_code": "CS",
    "question_no": "Q.65",
    "question_text": "Consider the following grammar along with translation rules.\n\nS -> S₁ # T  {S.val = S₁.val * T.val}\nS -> T        {S.val = T.val}\nT -> T₁ % R  {T.val = T₁.val / R.val}\nT -> R        {T.val = R.val}\nR -> id       {R.val = id.val}\n\nHere # and % are operators and id is a token that represents an integer and id.val represents the corresponding integer value. The set of non-terminals is {S, T, R} and a subscripted non-terminal indicates an instance of the non-terminal.\n\nUsing this translation scheme, the computed value of S.val for root of the parse tree for the expression 20#10%5#8%2%2 is ___.",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "syntax-directed translation",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE 2022 CS",
    "confidence": 1
  },
  {
    "year": 2023,
    "paper_code": "CS",
    "question_no": "Q.11",
    "question_text": "Consider the following statements regarding the front-end and back-end of a compiler.\nS1: The front-end includes phases that are independent of the target hardware.\nS2: The back-end includes phases that are specific to the target hardware.\nS3: The back-end includes phases that are specific to the programming language used in the source code.\nIdentify the CORRECT option.",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation (approximate)",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE-2023-CS-Paper",
    "confidence": 0.8
  },
  {
    "year": 2023,
    "paper_code": "CS",
    "question_no": "Q.36",
    "question_text": "Consider the following program: [C code with functions f1, f2, f3 and main]. Which one of the following options represents the activation tree corresponding to the main function?",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Runtime environments",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE-2023-CS-Paper",
    "confidence": 1
  },
  {
    "year": 2023,
    "paper_code": "CS",
    "question_no": "Q.37",
    "question_text": "Consider the control flow graph shown. Which one of the following choices correctly lists the set of live variables at the exit point of each basic block?",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Local optimization, Data flow analyses: constant propagation, liveness analysis, common sub expression elimination",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE-2023-CS-Paper",
    "confidence": 1
  },
  {
    "year": 2023,
    "paper_code": "CS",
    "question_no": "Q.60",
    "question_text": "Consider the syntax directed translation given by the following grammar and semantic rules. Here N, I, F and B are non-terminals. N is the starting non-terminal, and #, 0 and 1 are lexical tokens... The value computed by the translation scheme for the input string 10#011 is _______.",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE-2023-CS-Paper",
    "confidence": 1
  },
  {
    "year": 2024,
    "paper_code": "Computer Science and Information Technology Set 2 (CS2)",
    "question_no": "Q.21",
    "question_text": "Consider the following two sets:\nSet X\nP. Lexical Analyzer\nQ. Syntax Analyzer\nR. Intermediate Code Generator\nS. Code Optimizer\n\nSet Y\n1. Abstract Syntax Tree\n2. Token\n3. Parse Tree\n4. Constant Folding\n\nWhich one of the following options is the CORRECT match from Set X to Set Y?",
    "subject": "Compiler Design",
    "chapter": "Lexical analysis, parsing, syntax-directed translation.",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation.",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE2024_CS2_IISc",
    "confidence": 1
  },
  {
    "year": 2024,
    "paper_code": "Computer Science and Information Technology Set 2 (CS2)",
    "question_no": "Q.29",
    "question_text": "Which of the following statements is/are FALSE?\n\n(A) An attribute grammar is a syntax-directed definition (SDD) in which the functions in the semantic rules have no side effects\n(B) The attributes in a L-attributed definition cannot always be evaluated in a depth-first order\n(C) Synthesized attributes can be evaluated by a bottom-up parser as the input is parsed\n(D) All L-attributed definitions based on LR(1) grammar can be evaluated using a bottom-up parsing strategy",
    "subject": "Compiler Design",
    "chapter": "Lexical analysis, parsing, syntax-directed translation.",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation.",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE2024_CS2_IISc",
    "confidence": 1
  },
  {
    "year": 2024,
    "paper_code": "Computer Science and Information Technology Set 2 (CS2)",
    "question_no": "Q.40",
    "question_text": "Consider the following context-free grammar where the start symbol is S and the set of terminals is {a,b,c,d}.\nS → AaAb | BbBa\nA → cS | ε\nB → dS | ε\nThe following is a partially-filled LL(1) parsing table. Which one of the following options represents the CORRECT combination for the numbered cells in the parsing table?",
    "subject": "Compiler Design",
    "chapter": "Lexical analysis, parsing, syntax-directed translation.",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation.",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE2024_CS2_IISc",
    "confidence": 1
  },
  {
    "year": 2024,
    "paper_code": "Computer Science and Information Technology Set 2 (CS2)",
    "question_no": "Q.43",
    "question_text": "Consider the following expression: x[i] = (p + r) * −s[i] + u/w. The following sequence shows the list of triples representing the given expression, with entries missing for triples (1), (3), and (6). Which one of the following options fills in the missing entries CORRECTLY?",
    "subject": "Compiler Design",
    "chapter": "Intermediate code generation.",
    "subtopic": "Intermediate code generation.",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE2024_CS2_IISc",
    "confidence": 1
  },
  {
    "year": 2024,
    "paper_code": "Computer Science and Information Technology Set 2 (CS2)",
    "question_no": "Q.65",
    "question_text": "Consider the following augmented grammar, which is to be parsed with a SLR parser. The set of terminals is {a,b,c,d,#,@}\nS' → S\nS → SS | Aa | bAc | Bc | bBa\nA → d#\nB → @\nLet I₀ = CLOSURE({S' → • S}). The number of items in the set GOTO(I₀, S) is ________",
    "subject": "Compiler Design",
    "chapter": "Lexical analysis, parsing, syntax-directed translation.",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation.",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE2024_CS2_IISc",
    "confidence": 1
  },
  {
    "year": 2025,
    "paper_code": "CS1",
    "question_no": "Q.12",
    "question_text": "Which ONE of the following statements is FALSE regarding the symbol table?",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2025 CS1 Paper",
    "confidence": 0.9
  },
  {
    "year": 2025,
    "paper_code": "CS1",
    "question_no": "Q.13",
    "question_text": "Which ONE of the following techniques used in compiler code optimization uses live variable analysis?",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Local optimization, Data flow analyses: constant propagation, liveness analysis, common sub expression elimination",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2025 CS1 Paper",
    "confidence": 1
  },
  {
    "year": 2025,
    "paper_code": "CS1",
    "question_no": "Q.46",
    "question_text": "Which of the following statement(s) is/are TRUE while computing First and Follow during top down parsing by a compiler?",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Lexical analysis, parsing, syntax-directed translation",
    "theoretical_practical": "theoretical",
    "marks": 2,
    "provenance": "GATE 2025 CS1 Paper",
    "confidence": 1
  },
  {
    "year": 2025,
    "paper_code": "CS1",
    "question_no": "Q.52",
    "question_text": "Refer to the given 3-address code sequence. This code sequence is split into basic blocks. The number of basic blocks is ______. (Answer in integer)",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Intermediate code generation",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE 2025 CS1 Paper",
    "confidence": 1
  },
  {
    "year": 2025,
    "paper_code": "CS2",
    "question_no": "Q.21",
    "question_text": "Consider the following statements about the use of backpatching in a compiler for intermediate code generation:\n\n(I) Backpatching can be used to generate code for Boolean expression in one pass.\n(II) Backpatching can be used to generate code for flow-of-control statements in one pass.\n\nWhich ONE of the following options is CORRECT?",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "Intermediate code generation",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2025 Mock",
    "confidence": 1
  },
  {
    "year": 2025,
    "paper_code": "CS2",
    "question_no": "Q.22",
    "question_text": "Given the following syntax directed translation rules:\n\nRule 1: R → AB {B.i = R.i − 1; A.i = B.i; R.i = A.i + 1;}\nRule 2: P → CD {P.i = C.i + D.i; D.i = C.i + 2;}\nRule 3: Q → EF {Q.i = E.i + F.i;}\n\nWhich ONE is the CORRECT option among the following?",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "syntax-directed translation",
    "theoretical_practical": "theoretical",
    "marks": 1,
    "provenance": "GATE 2025 Mock",
    "confidence": 1
  },
  {
    "year": 2025,
    "paper_code": "CS2",
    "question_no": "Q.40",
    "question_text": "Given a Context-Free Grammar G as follows:\n\nS → Aa | bAc | dc | bda\nA → d\n\nWhich ONE of the following statements is TRUE?",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "parsing",
    "theoretical_practical": "practical",
    "marks": 2,
    "provenance": "GATE 2025 Mock",
    "confidence": 1
  },
  {
    "year": 2025,
    "paper_code": "CS2",
    "question_no": "Q.51",
    "question_text": "Consider two grammars G₁ and G₂ with the production rules given below:\n\nG₁: S → if E then S | if E then S else S | a\n    E → b\n\nG₂: S → if E then S | M\n    M → if E then M else S | c\n    E → b\n\nwhere if, then, else, a, b, c are the terminals.\nWhich of the following option(s) is/are CORRECT?",
    "subject": "Compiler Design",
    "chapter": "Compiler Design",
    "subtopic": "parsing",
    "theoretical_practical": "theoretical",
    "marks": 2,
    "provenance": "GATE 2025 Mock",
    "confidence": 1
  }
]